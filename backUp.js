'use strict';

const FOTOLOG = process.argv[2],
      $fetch = require('./$fetch'),
      fs = require('fs'),
      request = require('request'),
      mkdir = require("mkdir-promise"),
      MONTH_NAMES = [
        'January', 'February', 'March', 'April', 'May', 'June',  'July', 'August', 'September', 'October', 'November', 'December'
      ];


// Second to last object in `#description_photo > p` contents array
// is a text node automatically generated by Fotolog, informing post
// date. Ergo the use of `eq(-2)`.
function getPostDate($) {

  // "May" -> "05"  ;  "November" -> "11"
  function formatMonthToNumber(monthName) {
    const monthNum = MONTH_NAMES.indexOf(monthName) + 1;
    if (monthNum === 0) return new Error('Month’s no good.');

    return ( (monthNum < 10) ? '0' : '' ) + monthNum;
  }

  return Promise.resolve(
    $('#description_photo').children('p')
      .contents().eq(-2).text()
  ).then( dateStr => {

      dateStr = dateStr.trim();
      // now, `dateStr` is something like "On May 05 2005"

      const [year, month, day] = [
        dateStr.substr(-4),
        formatMonthToNumber(dateStr.substring(3, dateStr.length - 8)),
        dateStr.substr(-7, 2)
      ];

      return [$, year, month, day];
  });
}


function createDateDirectory($array) {

const [$, year, month, day] = $array;

  const date = year + '-' + month + '-' + day,
      path = './content/' + FOTOLOG + '/' + date + '/';

  return mkdir(path)
    .then( _=> console.log(`Diretório '${path}' criado.`),
           exception => console.error(exception) )
    .then( _=> [$, path]);
}



function backUp(URI) {

  // whilst developing, try just 3 handpicked posts
  /*const re = /(?:\d+)(?=\/$)/;
  let ID = ( URI.match(re) )[0];
  if (ID !== '14182234' && ID !== '10611508' && ID !== '10239857') {
    return;
  }*/

  return $fetch(URI)
    .then(getPostDate)
    .then(createDateDirectory)
    .then( $array => {

    const [$, path] = $array;

    let   picturePath     = path + 'picture.jpg',
          descriptionPath = path + 'post.txt',
          commentsPath    = path + 'comments.json';


    function backPictureUp() {
      const pictureURI = $('meta[property="og:image"]').prop('content');
      request(pictureURI).pipe(fs.createWriteStream(picturePath));
    }


    function backDescriptionUp() {
      let descrpt = $('meta[itemprop="description"]').prop('content');
      const defaultDescrpt = "Fotolog is the world's leading photo-blogging and social networking website.";

      // no description -> don’t save Fotolog’s default text
      // create an empty file called empty-post.txt instead.
      if (descrpt === defaultDescrpt) {
        descrpt = '';
        descriptionPath = path + 'empty-post.txt';
      } else {
        descrpt = descrpt.substring(0, descrpt.length - FOTOLOG.length - 3);
        descrpt = descrpt.replace(/\s?(?:<BR>\s)*<BR>$/, '');
        descrpt = descrpt.replace(/\s?<BR>\s<BR>\s?/g, '<BR>');
      }

      fs.writeFile(descriptionPath, descrpt, err => {
        if (err) return new Error('Description’s no good.');
        console.log(descriptionPath + ' saved.');
      });
    }


    function backCommentsUp() {
      let commentDIVs = $('.flog_img_comments').not('#comment_form');
      let commentsAmount = commentDIVs.length;
      let commentsJSON = [];

      if (commentsAmount === 0) {
        // no comments -> create ‘no-comments.json’ containing []
        commentsPath = path + 'no-comments.json';
        saveCommentsJSON(commentsJSON);
      } else {
        commentDIVs.each(makeCommentObj);
      }

      function makeCommentObj(i, el) {
        const memoized = el.firstChild.nextSibling.childNodes[0].firstChild;
        const author = memoized.children[0].data;
        const dateArr = memoized.parent.next.data
          .trim().substr(3)  /* e.g. '20/01/2005' */
            .split('/');     /* e.g. ['20', '01', '2005'] */
        const day = dateArr[0];
        const month = dateArr[1] - 1;
        const year = dateArr[2];
        const pTagContents = el.firstChild.nextSibling.childNodes;
        const comment = pTagContents.pop().data.trim();

        commentsJSON[i] = {
          author: author,
          date: new Date(year, month, day),
          content: comment
        };

        if (--commentsAmount === 0) {
          // Fotolog uses newest to oldest order. I don’t like it.
          commentsJSON.reverse();
          saveCommentsJSON(JSON.stringify(commentsJSON, null, '\t'));
        };
      }

      function saveCommentsJSON(commentsJSON) {
        fs.writeFile(commentsPath, commentsJSON, err => {
          if (err) return new Error('Comments are no good.');
          console.log(commentsPath + ' saved.');
        });
      }

    }


    backPictureUp();
    backDescriptionUp();
    backCommentsUp();

  }).catch( error => console.log(error) );

}


module.exports = backUp;
